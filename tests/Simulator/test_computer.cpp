#include "HardwareSimulator/Bit.hpp"
#include "HardwareSimulator/Computer.hpp"
#include "HardwareSimulator/Helper.hpp"
#include "HardwareSimulator/Memory.hpp"
#include "HardwareSimulator/Parser.hpp"

#include <boost/ut.hpp>

using namespace hack::defs;
using namespace boost::ut;

auto test_program_counter() -> void
{
  using InputType = std::tuple<int, int, int, int, int>;
  static const std::vector<InputType> Inputs = {
    {     0, 0, 0, 0,      0},
    {     0, 0, 0, 0,      0},
    {     0, 0, 0, 1,      1},
    {-32123, 0, 0, 1,      2},
    {-32123, 0, 1, 1, -32123},
    {-32123, 0, 0, 1, -32122},
    {-32123, 0, 0, 1, -32121},
    { 12345, 0, 1, 0,  12345},
    { 12345, 1, 1, 0,      0},
    { 12345, 0, 1, 1,  12345},
    { 12345, 1, 1, 1,      0},
    { 12345, 0, 0, 1,      1},
    { 12345, 1, 0, 1,      0},
    {     0, 0, 1, 1,      0},
    {     0, 0, 0, 1,      1},
    { 22222, 1, 0, 0,      0},
  };

  const size_t   iteration = Inputs.size();
  ProgramCounter pc        = FalseWord;
  for (size_t it = 0; it < iteration; ++it) {
    const auto [d_in, reset, load, inc, expected] = Inputs[it];

    auto in = int_to_word(d_in);

    auto b_actual = program_counter(pc, in, load, inc, reset);
    auto d_actual = word_to_int(b_actual);
    expect((expected == d_actual))
      << "at:" << it << ", expected:" << expected << ", actual:" << d_actual;
  }
}

auto test_cpu() -> void
{
  using InputType = std::tuple<Word, int, int, int, int, int, int, int>;

  //clang-format off
  static const std::vector<InputType> Data = {
    {{0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1},0, 0,0,0,12345,1,0        },
    {{1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
     0, 0,
     0, 0,
     12345,    2,
     12345  },
    {{0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0},
     0, 0,
     0, 0,
     23456,    3,
     12345  },
    {{1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0},
     0, 0,
     0, 0,
     11111,    4,
     11111  },
    {{0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1},
     0, 0,
     0, 0,
     1003,    5,
     11111  },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0},
     0, 0,
     11111, 1,
     1003,    6,
     11111  },
    {{0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0},
     0, 0,
     0, 0,
     1004,    7,
     11111  },
    {{1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0},
     0, 0,
     11110, 1,
     1004,    8,
     11110  },
    {{0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0},
     0, 0,
     0, 0,
     1000,    9,
     11110  },
    {{1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},
     11111, 0,
     0, 0,
     32767,   10,
     -1     },
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0},
     11111, 0,
     0, 0,
     14,   11,
     -1     },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0},
     11111, 0,
     0, 0,
     14,   14,
     -1     },
    {{0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1},
     11111, 0,
     0, 0,
     999,   15,
     -1     },
    {{1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0},
     11111, 0,
     0, 0,
     11112,   16,
     -1     },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0},
     11111, 0,
     -1,
     1,  32767,
     17,  -1},
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1},
     11111, 0,
     0, 0,
     21,   18,
     -1     },
    {{1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0},
     11111, 0,
     0, 0,
     21,   21,
     -1     },
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
     11111, 0,
     0, 0,
     2,   22,
     -1     },
    {{1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0},
     11111, 0,
     1, 1,
     1,   23,
     1      },
    {{1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0},
     11111, 0,
     11112, 1,
     1,   24,
     1      },
    {{1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0},
     11111, 0,
     11110, 1,
     11110,   25,
     1      },
    {{0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0},
     11111, 0,
     0, 0,
     1000,   26,
     1      },
    {{1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0},
     11111, 0,
     0, 0,
     1000,   27,
     -1     },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1},
     11111, 0,
     0, 0,
     1000,   28,
     -1     },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0},
     11111, 0,
     0, 0,
     1000,   29,
     -1     },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1},
     11111, 0,
     0, 0,
     1000,   30,
     -1     },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0},
     11111, 0,
     0, 0,
     1000, 1000,
     -1     },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1},
     11111, 0,
     0, 0,
     1000, 1000,
     -1     },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0},
     11111, 0,
     0, 0,
     1000, 1000,
     -1     },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1},
     11111, 0,
     0, 0,
     1000, 1000,
     -1     },
    {{1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0},
     11111, 0,
     0, 0,
     1000, 1001,
     0      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1},
     11111, 0,
     0, 0,
     1000, 1002,
     0      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0},
     11111, 0,
     0, 0,
     1000, 1000,
     0      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1},
     11111, 0,
     0, 0,
     1000, 1000,
     0      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0},
     11111, 0,
     0, 0,
     1000, 1001,
     0      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1},
     11111, 0,
     0, 0,
     1000, 1002,
     0      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0},
     11111, 0,
     0, 0,
     1000, 1000,
     0      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1},
     11111, 0,
     0, 0,
     1000, 1000,
     0      },
    {{1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0},
     11111, 0,
     0, 0,
     1000, 1001,
     1      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1},
     11111, 0,
     0, 0,
     1000, 1000,
     1      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0},
     11111, 0,
     0, 0,
     1000, 1001,
     1      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1},
     11111, 0,
     0, 0,
     1000, 1000,
     1      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0},
     11111, 0,
     0, 0,
     1000, 1001,
     1      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1},
     11111, 0,
     0, 0,
     1000, 1000,
     1      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0},
     11111, 0,
     0, 0,
     1000, 1001,
     1      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1},
     11111, 0,
     0, 0,
     1000, 1000,
     1      },
    {{1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1},
     11111, 1,
     0, 0,
     1000,    0,
     1      },
    {{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
     11111, 0,
     0, 0,
     32767,    1,
     1      },
  };
  //clang-format on
  const size_t iteration = Data.size();
  CPU          cpu_state;

  for (size_t it = 0; it < iteration; ++it) {
    const auto [inst, inM, reset, outM, writeM, addr, d_pc, d_dreg] = Data[it];

    //auto address   = int_to_word(addr);

    //auto address = r_address;
    //std::ranges::reverse(address);
    auto input = int_to_word(inM);

    auto instruction = inst;
    std::ranges::reverse(instruction);

    //tick
    cpu(cpu_state, input, instruction, reset);
    //tock
    //cpu(cpu_state, input, instruction, reset);

    if (outM != 0) {
      auto d_out_m = word_to_int(cpu_state.alu_out);
      expect((outM == d_out_m))
        << "at:" << it << "For outM-> actual:" << d_out_m
        << ", required:" << outM;
    }

    expect((Bit(writeM) == cpu_state.write_m))
      << "at:" << it << "For writeM-> actual:" << cpu_state.write_m
      << ", required:" << writeM;

    auto d_a_pc = word_to_int(cpu_state.pc);
    expect(d_pc == d_a_pc) << "at:" << it << "For pc-> actual:" << d_a_pc
                           << ", required:" << d_pc;

    auto d_a_dreg = word_to_int(cpu_state.reg_d);
    expect(d_a_dreg == d_dreg)
      << "at:" << it << "For d-register-> actual:" << d_a_dreg
      << ", required:" << d_dreg;
    //auto d_actual = word_to_int(b_actual);
    //expect((expected == d_actual))
    //  << "at:" << it << ", address:" << word_to_int(r_address)
    //  << ", expected:" << expected << ", actual:" << d_actual;
  }
}

auto test_memory() -> void
{
  //in,load,address,out
  using InputType = std::tuple<int, int, Word, int>;

  static const std::vector<InputType> Data = {
    {12345, 1, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     0},
    {12345, 1, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    {12345, 1, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     0},
    {12345, 1, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    {   -1, 1, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     0},
    {   -1, 1, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    -1},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    -1},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    -1},
    { 9999, 0, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    { 9999, 0, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    {12345, 1, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    -1},
    {12345, 1, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    {12345, 1, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    {12345, 1, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    { 2222, 1, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    { 2222, 1, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  2222},
    { 9999, 0, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  2222},
    { 9999, 0, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  2222},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    { 9999, 0, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},     0},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},     0},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},     0},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},     0},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},     0},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},     0},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},     0},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},     0},
    { 9999, 0, {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},     0},
    { 9999, 0, {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},     0},
    { 9999, 0, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     0},
    { 9999, 0, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     0},
    { 9999, 0, {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     0},
    { 9999, 0, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  2222},
    { 1234, 1, {0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0},     0},
    { 1234, 1, {0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0},  1234},
    { 1234, 0, {0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0},     0},
    { 1234, 0, {1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0},     0},
    { 2345, 1, {0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1},     0},
    { 2345, 1, {0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1},  2345},
    { 2345, 0, {0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1},     0},
    { 2345, 0, {1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1},     0},
    {    0, 1, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 12345},
    {    0, 1, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     0},
    {    0, 1, {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    75},
    {12345, 1, {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},     0},
    {12345, 1, {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1}, 12345},
    {12345, 1, {0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},     0},
    {12345, 1, {0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1}, 12345},
    {   -1, 1, {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},     0},
    {   -1, 1, {1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1},     0},
    {   -1, 1, {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1}, 12345},
    {   -1, 1, {0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1}, 12345},
    {   -1, 0, {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0},     0},
    {   -1, 0, {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1},     0},
    {   -1, 0, {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1},     0},
    {   -1, 0, {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1},     0},
    {   -1, 0, {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},     0},
    {   -1, 0, {1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1},     0},
    {   -1, 0, {1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1},     0},
    {   -1, 0, {1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1},     0},
    {   -1, 0, {1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1},     0},
    {   -1, 0, {1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1},     0},
    {   -1, 0, {1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},     0},
    {   -1, 0, {1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},     0},
    {   -1, 0, {1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},     0},
    {   -1, 0, {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    89}
  };

  const size_t iteration = Data.size();
  Memory       ram;

  for (size_t it = 0; it < iteration; ++it) {
    const auto [d_in, d_load, r_address, expected] = Data[it];

    auto in   = int_to_word(d_in);
    auto load = Bit(d_load);

    auto address = r_address;
    std::ranges::reverse(address);
    int iaddr = address_to_int(std::span{address}.first<MemoryAddressSize>());
    if ((iaddr >= 16'284)) {
      continue;
    }

    auto b_actual =
      memory(ram, in, load, std::span{r_address}.first<MemoryAddressSize>());
    auto d_actual = word_to_int(b_actual);
    expect((expected == d_actual))
      << "at:" << it << ", address:"
      << address_to_int(std::span{address}.first<MemoryAddressSize>())
      << ", expected:" << expected << ", actual:" << d_actual;
  }
}

auto test_computer()
{
  "add"_test = [] {
    //2 + 3
    const std::vector<int> instructions = {
      2,       //0000000000000010, @2
      -5104,   //1110110000010000, D=A
      3,       //0000000000000011, @3
      -8048,   //1110000010010000, D=D+A
      0,       //0000000000000000, @0
      -7416    //1110001100001000, M=D
    };

    Computer comp;
    load_rom(comp.rom, instructions);
    for ([[maybe_unused]] const auto& it : instructions) {
      computer(comp, BitFalse);
    }

    auto result  = ram16k(comp.memory.ram, FalseWord, BitFalse,
                          std::span{FalseWord}.first<RAM16KAddressSize>());
    auto iresult = word_to_int(result);
    expect((iresult == 5)) << "2 + 3 == 5";   //NOLINT
  };

  "max"_test = [] {
    std::string_view str_instructions = {
      "0000000000000000\n"   //@0
      "1111110000010000\n"   //D=M
      "0000000000000001\n"   //@1
      "1111010011010000\n"   //D=D-M
      "0000000000001010\n"   //@10
      "1110001100000001\n"   //D;JGT
      "0000000000000001\n"   //@1
      "1111110000010000\n"   //D=M
      "0000000000001100\n"   //@12
      "1110101010000111\n"   //0;JMP
      "0000000000000000\n"   //@0
      "1111110000010000\n"   //D=M
      "0000000000000010\n"   //@2
      "1110001100001000\n"   //M=D
      "0000000000001110\n"   //@14
      "1110101010000111\n"   //0;JMP
    };

    //NOLINTBEGIN
    std::vector<std::tuple<int, int, int>> inputs = {
      {12345, 23456, 23456},
      {23456, 12345, 23456},
 //  {-12345, -23456, -12345},
  //  {-23456, -12345, -12345},
  //  {-12345,  23456,  23456},
  //  {-23456,  12345,  12345}
    };
    //NOLINTEND

    auto     instructions = parse(str_instructions, ParseFrom::Memory);
    Computer comp;
    load_rom(comp.rom, instructions);

    auto set_ram = [&comp](int value, int address) {
      auto                  word = int_to_word(value);
      auto                  addr = int_to_word(address);
      [[maybe_unused]] auto result =
        ram16k(comp.memory.ram, word, BitTrue,
               std::span{addr}.first<RAM16KAddressSize>());
    };

    auto res_addr = int_to_word(2);
    for (const auto& [in_a, in_b, expected] : inputs) {
      set_ram(in_a, 0);
      set_ram(in_b, 1);
      for ([[maybe_unused]] const auto& it : instructions) {
        computer(comp, BitFalse);
      }
      auto result  = ram16k(comp.memory.ram, FalseWord, BitFalse,
                            std::span{res_addr}.first<RAM16KAddressSize>());
      auto iresult = word_to_int(result);
      expect((iresult == expected))
        << "max(" << in_a << ", " << in_b << ") = actual:" << iresult
        << ", expected:" << expected;   //NOLINT
    }
  };
}

auto main() -> int
{
  "components"_test = [] {
    "pc"_test       = [] { test_program_counter(); };
    "memory"_test   = [] { test_memory(); };
    "cpu"_test      = [] { test_cpu(); };
    "computer"_test = [] { test_computer(); };
  };
}
